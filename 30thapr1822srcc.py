import osimport pandas as pdimport numpy as npfrom sklearn.decomposition import PCAimport matplotlib.pyplot as pltfrom sklearn.preprocessing import StandardScalerfrom scipy.optimize import curve_fitfrom scipy.stats import normfrom scipy.stats import pearsonrfrom scipy.stats import spearmanrfrom scipy.interpolate import CubicSpline# Specify the path to the first folder containing your text filesfolder_path_afb = '/Users/livvy/Documents/Pulsars project/B1822-09_afb_dataset/profile_data_afb'spin_down_data_afb = '/Users/livvy/Documents/Pulsars project/B1822-09_spin_down.txt'# Specify the path to the second folder containing your text filesfolder_path_dfb = '/Users/livvy/Downloads/B1822-09_dataset 2/profile_data'spin_down_data_dfb = '/Users/livvy/Documents/Pulsars project/mjd_nudot_err.txt'# Create empty lists to store DataFrames and file order for the first folderall_dataframes_afb = []file_order_afb = []MJD_afb = []# Loop through each file in the first folder in ascending orderfor filename_afb in sorted(os.listdir(folder_path_afb)):    if filename_afb.endswith('.txt'):        file_order_afb.append(filename_afb)        file_path_afb = os.path.join(folder_path_afb, filename_afb)        df_afb = pd.read_csv(file_path_afb, header=None, delimiter='\t')        values_afb = df_afb.values.flatten()        all_dataframes_afb.append(values_afb)        # get MJD from the filenames        extracted_chars_afb = filename_afb.replace('B1822-09_', '').replace('.txt', '')        num_value_afb = float(extracted_chars_afb)        num_list_afb = num_value_afb        MJD_afb.append(round(num_list_afb))# Read in spin down data for the first foldercolumns_afb = ['MJD', 'Spin-down rate (1e-15 Hz/s)', 'Spin-down rate uncertainty (1e-15 Hz/s)']spin_down_df_afb = pd.read_csv(spin_down_data_afb, delim_whitespace=True, names=columns_afb)# Create DataFrame for the first folderraw_df_afb = pd.DataFrame(all_dataframes_afb)# Create empty lists to store DataFrames and file order for the second folderall_dataframes_dfb = []file_order_dfb = []MJD_dfb = []# Loop through each file in the second folder in ascending orderfor filename_dfb in sorted(os.listdir(folder_path_dfb)):    if filename_dfb.endswith('.txt'):        file_order_dfb.append(filename_dfb)        file_path_dfb = os.path.join(folder_path_dfb, filename_dfb)        df_dfb = pd.read_csv(file_path_dfb, header=None, delimiter='\t')        values_dfb = df_dfb.values.flatten()        all_dataframes_dfb.append(values_dfb)        # get MJD from the filenames        extracted_chars_dfb = filename_dfb.replace('B1822-09_', '').replace('.txt', '')        num_value_dfb = float(extracted_chars_dfb)        num_list_dfb = num_value_dfb        MJD_dfb.append(round(num_list_dfb))# Read in spin down data for the second foldercolumns_dfb = ['MJD', 'Spin-down rate (1e-15 Hz/s)', 'Spin-down rate uncertainty (1e-15 Hz/s)']spin_down_df_dfb = pd.read_csv(spin_down_data_dfb, delim_whitespace=True, names=columns_afb)# Create DataFrame for the second folderraw_df_dfb = pd.DataFrame(all_dataframes_dfb)#drop rows#rows_to_drop = [6, 64, 137, 147, 227, 298, 432, 433, 440, 442, 446,448, 449, 452, 453, 460,461, 468, 504, 606, 622, 691, 720, 722, 818, 821, 836, 839, 846]#raw_df_dfb = raw_df_dfb.drop(rows_to_drop)#MJD_dfb = MJD_dfb.drop(rows_to_drop)def closest_index(arr, value):    closest_index = 0    min_diff = abs(arr[0] - value)    for i in range(1, len(arr)):        diff = abs(arr[i] - value)        if diff < min_diff:            min_diff = diff            closest_index = i    return closest_indexdef plotstackedintensities(matrix):    #Display the stacked pca reconstruction    n_components = 2    plt.figure(figsize=(10, 6))    plt.imshow(((matrix)), cmap='inferno', aspect='auto')    plt.colorbar()    plt.title(f'Horizontally Stacked Intensity Curves reconstruction with {n_components} PCs')    plt.xlabel('Phase bin')    plt.ylabel('Observation Number')    plt.show()    returndef gaussian_func(x, mu, sigma, A):    return A*norm.pdf(x, loc=mu, scale=sigma)def normbygaussian_afb(dataframe):    raw_df = dataframe    peak_subset_df = dataframe.iloc[:, np.r_[94:120]]    bin_averages = np.mean(peak_subset_df, axis=0)                #get profile shape    scaler = []    ideal_params, covariance = curve_fit(gaussian_func, np.arange(len(bin_averages)), bin_averages)    mu_fit = ideal_params[0]    sigma_fit = ideal_params[1]    A_fit = ideal_params[2]    for i in range(0,len(raw_df.iloc[:,1])):        ideal_params_obs, covarianceobs = curve_fit(gaussian_func, np.arange(len(peak_subset_df.iloc[i,:])), peak_subset_df.iloc[i,:], maxfev = 5000)        A_fit_obs = ideal_params_obs[2]        scaling = A_fit / A_fit_obs        scaler.append(scaling)    normalised_by_fit_df = raw_df.mul(scaler, axis=0)    return(normalised_by_fit_df)def normbygaussian_dfb(dataframe):    raw_df = dataframe    #peak_subset_df = dataframe.iloc[:, np.r_[94:120]] #FOR AFB!!!!    peak_subset_df = dataframe.iloc[:, np.r_[240:290]]    bin_averages = np.mean(peak_subset_df, axis=0)                #get profile shape    scaler = []    ideal_params, covariance = curve_fit(gaussian_func, np.arange(len(bin_averages)), bin_averages)    mu_fit = ideal_params[0]    sigma_fit = ideal_params[1]    A_fit = ideal_params[2]    def new_gaussian_func(x, A):        return A*norm.pdf(x, loc=mu_fit, scale=sigma_fit)    for i in range(0,len(raw_df.iloc[:,1])):        ideal_params_obs, covarianceobs = curve_fit(new_gaussian_func, np.arange(len(peak_subset_df.iloc[i,:])), peak_subset_df.iloc[i,:], maxfev = 5000)        A_fit_obs = ideal_params_obs[0]        scaling = A_fit / A_fit_obs        scaler.append(scaling)    normalised_by_fit_df = raw_df.mul(scaler, axis=0)    return(normalised_by_fit_df)def dopca(dataset,n_components, subset_range):    '''use:    pcaresult = dopca(dfaveragenorm,2)    plotPCsandshape4(pcaresult[1].iloc[0,:], pcaresult[1].iloc[1,:], pcaresult[0],pcaresult[2],days)     where: plotPCsandshape4(pc1, pc2, EIGENVALUES, matrix, days)    '''    dataset = pd.DataFrame(dataset)    if subset_range is not None and subset_range.size > 0:        dataset = dataset.iloc[:, subset_range]    else:        dataset = dataset    pca = PCA(n_components=n_components) #defines the pca action    principalComponents = pca.fit_transform(dataset)    evals = pd.DataFrame(data=principalComponents)    evecs = pd.DataFrame(data=pca.components_)    varianceratio = pca.explained_variance_ratio_    mean = pca.mean_    reconstructeddf = mean + evals @ evecs    return(evals,evecs,reconstructeddf,varianceratio,mean)def smooth_sp_and_days(days, shape_parameters, window_size):    days = np.array(days)    num_days = int(days[len(days)-1] - days[0]) +1    overlap = window_size // 4 #step size    num_windows = (num_days - window_size) // overlap + 1    mean_shape_parameters = []    mean_day_values = []    for i in range(num_windows):        start_day = days[0] + i * overlap        end_day = start_day + window_size        window_indices = [j for j, day in enumerate(days) if start_day <= day < end_day]        window_shape_parameters = [shape_parameters[j] for j in window_indices]        if window_shape_parameters:            mean_shape_parameter = np.mean(window_shape_parameters)            mean_shape_parameters.append(mean_shape_parameter)            mean_day_value = start_day + (window_size / 2)            mean_day_values.append(mean_day_value)    return(mean_day_values,mean_shape_parameters)def get_evenly_spaced_days(mjd):    mjd = np.array(mjd)    initial = mjd[0]    final = mjd[len(mjd)-1]    #num_values = len(mjd)    num_values = final - initial    #evenly_spaced_mjd = np.linspace(initial, final, num=num_values)    interval = (final - initial) / (num_values - 1)    print(interval)    #evenly_spaced_mjd = np.round(np.linspace(initial, final, num_values)).astype(int)    evenly_spaced_mjd = np.arange(initial, final + 2, interval, dtype=int)    print(f'{evenly_spaced_mjd} = evenly spaced days')    new_mjd = []    for entry in evenly_spaced_mjd:        given_value = entry        absolute_diff = np.abs(given_value -  mjd)        closest_index = np.argmin(absolute_diff)        closest_day = mjd[closest_index]        #print(f'closest_day= {closest_day}')        new_mjd.append(closest_day)    return(np.array(new_mjd).flatten())def plotpcs(MJD, evenMJD, data, n):    eigenvalues,eigenvectors,reconstruction,exp_var,mean = dopca(data, n, None)    transposed_matrix = createeven_df_andtranspose(MJD, evenMJD, data)    fig, axes = plt.subplots(n+1, 2, figsize=(10, 6))    axes[0, 0].imshow(transposed_matrix, cmap='inferno', aspect='auto')    axes[0, 0].set_ylabel('original')    axes[0, 0].xaxis.set_visible(False)    axes[0, 0].yaxis.set_ticks([])    axes[0, 1].plot(np.arange(len(mean_dfb)),mean_dfb)    axes[0, 1].set_ylabel('mean')    axes[0, 1].xaxis.set_visible(False)    for i in range(n):        single_eval = pd.DataFrame(eigenvalues.iloc[:, i])        single_evec = pd.DataFrame(eigenvectors.iloc[i ,:]).T        single_recon = single_eval @ single_evec        even_single_recon = createeven_df_andtranspose(MJD, evenMJD,single_recon)        axes[i+1, 0].imshow(even_single_recon, cmap='inferno', aspect='auto')        axes[i+1, 0].set_xlabel('MJD')        axes[i+1, 0].set_ylabel(f'PC{i +1 }')        axes[i+1, 0].grid(False)        axes[i+1, 0].xaxis.set_visible(False)        axes[i+1, 0].yaxis.set_ticks([])        axes[i+1, 1].plot(np.arange(len(eigenvectors.iloc[i,:])),eigenvectors.iloc[i,:])        axes[i+1, 1].set_xlabel('phase')        axes[i+1, 1].grid(False)        axes[i+1, 1].xaxis.set_visible(False)    fig.suptitle('Principal components B1822-09 AFB')    im = axes[0, 0].imshow(transposed_matrix, cmap='inferno', aspect='auto')    cbar_ax = fig.add_axes([0, 1, 0.3, 0.015])    fig.colorbar(im,cax=cbar_ax, orientation='horizontal')    plt.subplots_adjust(top=0.9,hspace=0)    plt.tight_layout()  # Adjust layout to prevent overlap    plt.show()    return()def createeven_df_andtranspose(days, evendays, normaliseddf):    normaliseddf = pd.DataFrame(normaliseddf)    new_matrix = []    for entry in evendays:        #find row with nearest        given_value = entry        absolute_diff = np.abs(days - given_value)        index = np.argmin(absolute_diff) #finds the row index with the day nearest to that of even day        row_to_append = normaliseddf.iloc[index]        row_to_append = np.array(row_to_append)        new_matrix.append(row_to_append) #this is the normalised df in the even spacing but not transposed    transposed_matrix = [[row[i] for row in new_matrix] for i in range(len(new_matrix[0]))]    transposed_matrix = np.array(transposed_matrix)    return(np.array(transposed_matrix))def transpose(data):    data = np.array(data)    data = [[row[i] for row in data] for i in range(len(data[0]))]    data = np.array(data)    return(data)def plot_pcs(dataset, n, subset):    eigenvalues, eigenvectors, matrix, variance = dopca(dataset, n, subset)    print(variance)    if n == 1:        plt.figure(figsize=(10, 6))        plt.plot(np.arange(len(eigenvectors.iloc[0,:])),eigenvectors.iloc[0,:])        plt.text(0,0,f'exp var = {variance}')        plt.xlabel('phase')        plt.ylabel(f'PC{n}')        plt.title('Principal components')    else:        fig, axes = plt.subplots(n, 1, figsize=(10, 6))        for i in range(n):            axes[i].plot(np.arange(len(eigenvectors.iloc[i,:])),eigenvectors.iloc[i,:])            axes[i].set_xlabel('phase')            axes[i].set_ylabel(f'PC{i}')        fig.suptitle('Principal components')        plt.subplots_adjust(hspace=0)        plt.tight_layout()  # Adjust layout to prevent overlap        plt.show()window = 100num_comp = 4SNr_cutoff = 15#need to normalise, get pca reconstructions and then plot against spin down ratenormalised_df_afb0 = normbygaussian_afb(raw_df_afb)subset_range_afb = np.concatenate((np.arange(60, 110), np.arange(290, 320)))normalised_df_afb = normalised_df_afb0.iloc[:, subset_range_afb]# days array is called MJD_afbnormalised_df_dfb0 = normbygaussian_dfb(raw_df_dfb)rows_to_drop = []SNr_arr = []for i in range(len(normalised_df_dfb0.iloc[:,1])):    obs = normalised_df_dfb0.iloc[i,:]    noise_reigon = obs[400:600] #get off pulse region    noise = np.std(noise_reigon)    signal = np.max(obs) #calc peak value of pulse    SNr = signal / noise    SNr_arr.append(SNr)    if SNr < SNr_cutoff:        rows_to_drop.append(i)#make code for this all on one- sp must correpsond tonormalised_df_dfb = normalised_df_dfb0.drop(rows_to_drop)subset_range_dfb = np.concatenate((np.arange(160, 291), np.arange(750, 801)))subset_range_dfb1 = (np.arange(750, 800))normalised_df_dfb = normalised_df_dfb.iloc[:, subset_range_dfb]#plotstackedintensities(normalised_df_dfb)#assign values:94:120MJD_dfb = pd.DataFrame(MJD_dfb)MJD_dfb = MJD_dfb.drop(rows_to_drop)MJD_dfb = np.array(MJD_dfb)from itertools import chainMJD_dfb = list(chain.from_iterable(MJD_dfb))eigenvalues_afb,eigenvectors_afb,reconstruction_afb,exp_var_afb,mean_afb = dopca(normalised_df_afb, num_comp, None)shape_parameter_afb = eigenvalues_afb.iloc[:,0] #shape parameter is from the first principal component#plotstackedintensities(dopca(normalised_df_afb,2)[2]) #plot stacked intensities to check pca working as expectedcolumn_averages_afb = eigenvalues_afb.mean(axis=1)average_df_afb = pd.DataFrame(column_averages_afb)#shape_parameter_afb = column_averages_afbeigenvalues_dfb,eigenvectors_dfb,reconstruction_dfb,exp_var_dfb,mean_dfb = dopca(normalised_df_dfb, num_comp, None)shape_parameter_dfb = eigenvalues_dfb.iloc[:,0]#plotstackedintensities(dopca(normalised_df_dfb, num_comp)[2]) #plot stacked intensities to check pca working as expectedcolumn_averages_dfb = eigenvalues_dfb.mean(axis=1)average_df_dfb = pd.DataFrame(column_averages_dfb)#shape_parameter_dfb = column_averages_dfbspindown_MJD_afb = spin_down_df_afb.iloc[:,0]spindown_rate_afb = spin_down_df_afb.iloc[:,1]spindown_MJD_dfb = spin_down_df_dfb.iloc[:,0]spindown_rate_dfb = spin_down_df_dfb.iloc[:,1]#assign smoothed valuessmoothed_spindown_MJD_afb, smoothed_spindown_rate_afb = smooth_sp_and_days(spindown_MJD_afb,spindown_rate_afb, window)smoothed_MJD_afb, smoothed_shape_parameter_afb = smooth_sp_and_days(MJD_afb,shape_parameter_afb, window)smoothed_spindown_MJD_dfb, smoothed_spindown_rate_dfb = smooth_sp_and_days(spindown_MJD_dfb,spindown_rate_dfb, window)smoothed_MJD_dfb, smoothed_shape_parameter_dfb = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb, window)evenly_spaced_mjd_dfb = get_evenly_spaced_days(MJD_dfb)transposed_matrix_dfb = createeven_df_andtranspose(MJD_dfb, evenly_spaced_mjd_dfb, normalised_df_dfb)evenly_spaced_mjd_afb = get_evenly_spaced_days(MJD_afb)transposed_matrix_afb = createeven_df_andtranspose(MJD_afb, evenly_spaced_mjd_afb, normalised_df_afb)even_recon_afb = createeven_df_andtranspose(MJD_afb,evenly_spaced_mjd_afb,reconstruction_afb)even_recon_dfb = createeven_df_andtranspose(MJD_dfb,evenly_spaced_mjd_dfb,reconstruction_dfb)fig, axes = plt.subplots(num_comp+1, 2, figsize=(9, 6), gridspec_kw={'width_ratios': [1,0.15]})axes[0, 0].imshow(transposed_matrix_dfb, cmap='inferno', aspect='auto')axes[0, 0].set_ylabel('original')axes[0, 0].xaxis.set_visible(False)axes[0, 0].yaxis.set_ticks([])axes[0, 1].plot(mean_dfb,np.arange(len(mean_dfb)))axes[0, 1].invert_yaxis()axes[0, 1].set_ylabel('mean')axes[0, 1].xaxis.set_visible(False)for i in range(num_comp):    single_eval_dfb = pd.DataFrame(eigenvalues_dfb.iloc[:, i])    single_evec_dfb = pd.DataFrame(eigenvectors_dfb.iloc[i ,:]).T    single_recon_dfb = single_eval_dfb @ single_evec_dfb    even_single_recon_dfb = createeven_df_andtranspose(MJD_dfb,evenly_spaced_mjd_dfb,single_recon_dfb)    axes[i+1, 0].imshow(even_single_recon_dfb, cmap='inferno', aspect='auto')    axes[i+1, 0].set_xlabel('MJD')    axes[i+1, 0].set_ylabel(f'PC{i +1 }')    axes[i+1, 0].grid(False)    axes[i+1, 0].xaxis.set_visible(False)    axes[i+1, 0].yaxis.set_ticks([])    axes[i+1, 1].plot(eigenvectors_dfb.iloc[i,:],np.arange(len(eigenvectors_dfb.iloc[i,:])))    axes[i+1, 1].invert_yaxis()    axes[i+1, 1].set_xlabel('phase')    axes[i+1, 1].grid(False)    axes[i+1, 1].xaxis.set_visible(False)fig.suptitle('Principal components B1822−09 DFB')im = axes[0, 0].imshow(transposed_matrix_dfb, cmap='inferno', aspect='auto')cbar_ax = fig.add_axes([0.05, 1, 0.3, 0.015])fig.colorbar(im,cax=cbar_ax, orientation='horizontal')plt.subplots_adjust(top=0.9,hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()#DFB!fig, axes = plt.subplots(5, 1, figsize=(20, 12), gridspec_kw={'height_ratios': [1,0.1,1, 0.5, 0.5]})# Plot the transposed matrix on the first subplotaxes[0].imshow(transposed_matrix_dfb, cmap='inferno', aspect='auto')axes[0].set_xlabel('MJD')axes[0].set_ylabel('normalised intensities')axes[0].grid(False)axes[0].xaxis.set_visible(False)axes[1].plot()axes[1].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])for x in np.array(MJD_dfb):    axes[1].axvline(x)axes[1].yaxis.set_visible(False)axes[1].xaxis.set_visible(False)# Plot the PCA 2nd sublotaxes[2].imshow(even_recon_dfb, cmap='inferno', aspect='auto')axes[2].set_xlabel('MJD')axes[2].set_ylabel(f'PCA w/ {num_comp} components')axes[2].grid(False)axes[2].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[3].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb, color='red')axes[3].set_ylabel(f'shape param (window= {window})')axes[3].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[3].xaxis.set_visible(False)# Plot the third panelaxes[4].plot(spindown_MJD_dfb, spindown_rate_dfb, color='blue')  # Replace x_data and y_data with your dataaxes[4].set_xlabel('Modified Julian Days')  # Replace with appropriate labelaxes[4].set_ylabel('Spindown')  # Replace with appropriate labelaxes[4].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])fig.suptitle('DFB emission modes shown by colourmap, shape parameter and spindown rate against days', fontsize=16)plt.subplots_adjust(hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()#DFB SPsfig, axes = plt.subplots(5, 1, figsize=(20, 12), gridspec_kw={'height_ratios': [0.5,0.5,0.5,0.5, 0.5]})shape_parameter_dfb = eigenvalues_dfb.iloc[:,0]shape_parameter_dfb1 = eigenvalues_dfb.iloc[:,1]shape_parameter_dfb2 = eigenvalues_dfb.iloc[:,2]shape_parameter_dfb3 = eigenvalues_dfb.iloc[:,3]smoothed_shape_parameter_dfb = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb, window)[1]smoothed_shape_parameter_dfb1 = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb1, window)[1]smoothed_shape_parameter_dfb2 = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb2, window)[1]smoothed_shape_parameter_dfb3 = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb3, window)[1]# Plot the spindown dfb on the second subplotaxes[0].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb, color='red')axes[0].set_ylabel(f'SP 1')axes[0].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[0].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[1].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb1, color='red')axes[1].set_ylabel(f'SP 2')axes[1].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[1].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[2].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb2, color='red')axes[2].set_ylabel(f'SP 3')axes[2].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[2].xaxis.set_visible(False)axes[3].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb3, color='red')axes[3].set_ylabel(f'SP 4')axes[3].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[3].xaxis.set_visible(False)# Plot the third panelaxes[4].plot(spindown_MJD_dfb, spindown_rate_dfb, color='blue')  # Replace x_data and y_data with your dataaxes[4].set_xlabel('Modified Julian Days')  # Replace with appropriate labelaxes[4].set_ylabel('Spindown')  # Replace with appropriate labelaxes[4].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])fig.suptitle(f'B1822-09 DFB shape parameters and spindown rate (window = {window})', fontsize=16)plt.subplots_adjust(hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()#AFB!fig, axes = plt.subplots(5, 1, figsize=(20, 12), gridspec_kw={'height_ratios': [1,0.1,1, 0.5, 0.5]})# Plot the transposed matrix on the first subplotaxes[0].imshow(transposed_matrix_afb, cmap='inferno', aspect='auto')axes[0].set_xlabel('MJD')axes[0].set_ylabel('phase intensities',fontsize = 18)axes[0].grid(False)axes[0].xaxis.set_visible(False)axes[1].plot()axes[1].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])for x in np.array(MJD_afb):    axes[1].axvline(x)axes[1].xaxis.set_visible(False)axes[1].yaxis.set_visible(False)# Plot the PCA 2nd sublotaxes[2].imshow(even_recon_afb, cmap='inferno', aspect='auto')axes[2].set_xlabel('MJD')axes[2].set_ylabel(f'PCA reconstruction',fontsize = 18)axes[2].grid(False)axes[2].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[3].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb, color='red')axes[3].set_ylabel(f'Shape param',fontsize = 18)axes[3].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[3].xaxis.set_visible(False)# Plot the third panelaxes[4].plot(spindown_MJD_dfb, spindown_rate_dfb, color='blue')axes[4].set_xlabel('Modified Julian Days', fontsize = 18)axes[4].set_ylabel('Spindown',fontsize = 18)axes[4].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[4].tick_params(axis='x', labelsize=16)fig.suptitle('AFB emission modes shown by colourmap, shape parameter and spindown rate against days', fontsize=20)plt.subplots_adjust(hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()#DFB!fig, axes = plt.subplots(8, 1, figsize=(20, 12), gridspec_kw={'height_ratios': [1,0.1,1, 0.5,0.5,0.5,0.5, 0.5]})# Plot the transposed matrix on the first subplotaxes[0].imshow(transposed_matrix_dfb, cmap='inferno', aspect='auto')axes[0].set_xlabel('MJD')axes[0].set_ylabel('normalised intensities')axes[0].grid(False)axes[0].xaxis.set_visible(False)axes[1].plot()axes[1].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])for x in np.array(MJD_dfb):    axes[1].axvline(x)axes[1].xaxis.set_visible(False)# Plot the PCA 2nd sublotaxes[2].imshow(even_recon_dfb, cmap='inferno', aspect='auto')axes[2].set_xlabel('MJD')axes[2].set_ylabel(f'PCA w/ {num_comp} components')axes[2].grid(False)axes[2].xaxis.set_visible(False)shape_parameter_dfb = eigenvalues_dfb.iloc[:,0]shape_parameter_dfb1 = eigenvalues_dfb.iloc[:,1]shape_parameter_dfb2 = eigenvalues_dfb.iloc[:,2]shape_parameter_dfb3 = eigenvalues_dfb.iloc[:,3]smoothed_shape_parameter_dfb = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb, window)[1]smoothed_shape_parameter_dfb1 = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb1, window)[1]smoothed_shape_parameter_dfb2 = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb2, window)[1]smoothed_shape_parameter_dfb3 = smooth_sp_and_days(MJD_dfb,shape_parameter_dfb3, window)[1]# Plot the spindown dfb on the second subplotaxes[3].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb, color='red')axes[3].set_ylabel(f'SP 1')axes[3].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[3].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[4].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb1, color='red')axes[4].set_ylabel(f'SP 2')axes[4].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[4].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[5].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb2, color='red')axes[5].set_ylabel(f'SP 3')axes[5].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[5].xaxis.set_visible(False)axes[6].plot(smoothed_MJD_dfb, smoothed_shape_parameter_dfb3, color='red')axes[6].set_ylabel(f'SP 4')axes[6].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[6].xaxis.set_visible(False)# Plot the third panelaxes[7].plot(spindown_MJD_dfb, spindown_rate_dfb, color='blue')  # Replace x_data and y_data with your dataaxes[7].set_xlabel('Modified Julian Days')  # Replace with appropriate labelaxes[7].set_ylabel('Spindown')  # Replace with appropriate labelaxes[7].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])fig.suptitle('dfb emission modes shown by colourmap, shape parameter and spindown rate against days', fontsize=16)plt.subplots_adjust(hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()#AFB!fig, axes = plt.subplots(8, 1, figsize=(20, 12), gridspec_kw={'height_ratios': [1,0.1,1, 0.5,0.5,0.5,0.5, 0.5]})# Plot the transposed matrix on the first subplotaxes[0].imshow(transposed_matrix_afb, cmap='inferno', aspect='auto')axes[0].set_xlabel('MJD')axes[0].set_ylabel('normalised intensities')axes[0].grid(False)axes[0].xaxis.set_visible(False)axes[1].plot()axes[1].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])for x in np.array(MJD_afb):    axes[1].axvline(x)axes[1].xaxis.set_visible(False)# Plot the PCA 2nd sublotaxes[2].imshow(even_recon_afb, cmap='inferno', aspect='auto')axes[2].set_xlabel('MJD')axes[2].set_ylabel(f'PCA w/ {num_comp} components')axes[2].grid(False)axes[2].xaxis.set_visible(False)shape_parameter_afb = eigenvalues_afb.iloc[:,0]shape_parameter_afb1 = eigenvalues_afb.iloc[:,1]shape_parameter_afb2 = eigenvalues_afb.iloc[:,2]shape_parameter_afb3 = eigenvalues_afb.iloc[:,3]smoothed_shape_parameter_afb = smooth_sp_and_days(MJD_afb,shape_parameter_afb, window)[1]smoothed_shape_parameter_afb1 = smooth_sp_and_days(MJD_afb,shape_parameter_afb1, window)[1]smoothed_shape_parameter_afb2 = smooth_sp_and_days(MJD_afb,shape_parameter_afb2, window)[1]smoothed_shape_parameter_afb3 = smooth_sp_and_days(MJD_afb,shape_parameter_afb3, window)[1]# Plot the spindown dfb on the second subplotaxes[3].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb, color='red')axes[3].set_ylabel(f'SP 1')axes[3].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[3].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[4].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb1, color='red')axes[4].set_ylabel(f'SP 2')axes[4].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[4].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[5].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb2, color='red')axes[5].set_ylabel(f'SP 3')axes[5].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[5].xaxis.set_visible(False)axes[6].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb3, color='red')axes[6].set_ylabel(f'SP 4')axes[6].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[6].xaxis.set_visible(False)# Plot the third panelaxes[7].plot(spindown_MJD_dfb, spindown_rate_dfb, color='blue')  # Replace x_data and y_data with your dataaxes[7].set_xlabel('Modified Julian Days')  # Replace with appropriate labelaxes[7].set_ylabel('Spindown')  # Replace with appropriate labelaxes[7].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])fig.suptitle('!AFB emission modes shown by colourmap, shape parameter and spindown rate against days', fontsize=16)plt.subplots_adjust(hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()column_av = normalised_df_dfb0.mean(axis=0)plt.plot(np.arange(len(column_av)),column_av)plt.xlabel('Phase bin')plt.ylabel('Intensity')plt.title('B1822-09 average profile')plt.show()onerow = normalised_df_dfb0.iloc[500,:]plt.plot(np.arange(len(onerow)),onerow)plt.xlabel('Phase bin')plt.ylabel('Intensity')plt.title('B1822-09 one profile')plt.show()#AFB zoom!start = 5000stop = 5200fig, axes = plt.subplots(2, 1, figsize=(20, 12), gridspec_kw={'height_ratios': [1,0.1]})# Plot the transposed matrix on the first subplotaxes[0].imshow(transposed_matrix_afb[:,start:stop+1], cmap='inferno', aspect='auto')axes[0].set_xlabel('MJD')axes[0].set_ylabel('phase intensities',fontsize = 18)axes[0].grid(False)axes[0].xaxis.set_visible(False)axes[1].plot()axes[1].set_xlim((evenly_spaced_mjd_afb[start]-0.5)-1, (evenly_spaced_mjd_afb[stop]+0.5))for x in np.array(MJD_afb):    axes[1].axvline(x)axes[1].xaxis.set_visible(False)axes[1].yaxis.set_visible(False)fig.suptitle('AFB emission modes shown by colourmap', fontsize=20)plt.subplots_adjust(hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()#AFB!fig, axes = plt.subplots(5, 1, figsize=(20, 12), gridspec_kw={'height_ratios': [0.5,0.5,0.5,0.5, 0.5]})shape_parameter_afb = eigenvalues_afb.iloc[:,0]shape_parameter_afb1 = eigenvalues_afb.iloc[:,1]shape_parameter_afb2 = eigenvalues_afb.iloc[:,2]shape_parameter_afb3 = eigenvalues_afb.iloc[:,3]smoothed_shape_parameter_afb = smooth_sp_and_days(MJD_afb,shape_parameter_afb, window)[1]smoothed_shape_parameter_afb1 = smooth_sp_and_days(MJD_afb,shape_parameter_afb1, window)[1]smoothed_shape_parameter_afb2 = smooth_sp_and_days(MJD_afb,shape_parameter_afb2, window)[1]smoothed_shape_parameter_afb3 = smooth_sp_and_days(MJD_afb,shape_parameter_afb3, window)[1]# Plot the spindown dfb on the second subplotaxes[0].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb, color='red')axes[0].set_ylabel(f'SP 1')axes[0].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[0].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[1].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb1, color='red')axes[1].set_ylabel(f'SP 2')axes[1].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[1].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[2].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb2, color='red')axes[2].set_ylabel(f'SP 3')axes[2].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[2].xaxis.set_visible(False)axes[3].plot(smoothed_MJD_afb, smoothed_shape_parameter_afb3, color='red')axes[3].set_ylabel(f'SP 4')axes[3].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[3].xaxis.set_visible(False)# Plot the third panelaxes[4].plot(spindown_MJD_afb, spindown_rate_afb, color='blue')  # Replace x_data and y_data with your dataaxes[4].set_xlabel('Modified Julian Days')  # Replace with appropriate labelaxes[4].set_ylabel('Spindown')  # Replace with appropriate labelaxes[4].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])fig.suptitle(f'B1822-09 AFB shape parameters and spindown rate (window = {window})', fontsize=16)plt.subplots_adjust(hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()'''def resample(days_target,days_old,old):    resampled_shape_parameters = []    days_old = np.array(days_old)    old = np.array(old)    days_target = np.array(days_target)    # Iterate through each value in spindown_MJD_afb    for mjd in days_target:        # Find the nearest corresponding value in MJD_afb        nearest_mjd_index = np.abs(days_old - mjd).argmin()        # Get the corresponding shape parameter value        shape_param = old[nearest_mjd_index]        # Append the shape parameter value to the resampled array        resampled_shape_parameters.append(shape_param)    return(resampled_shape_parameters)'''def calc_srcc(array1,array2):    array1 = np.array(array1)    array2 = np.array(array2)    correlation_coefficient1, _ = spearmanr(array1, array2)    #bootstrapping to find uncertainty    num_bootstrap_samples = 1000    correlation_coefficients = []    for _ in range(num_bootstrap_samples):        # Resample array1 with replacement        resampled_array1_indices = np.random.choice(len(array1), size=len(array1), replace=True)        resampled_array1 = array1[resampled_array1_indices]        # Calculate correlation coefficient for the resampled arrays        correlation_coefficient, _ = spearmanr(resampled_array1, array2)        correlation_coefficients.append(correlation_coefficient)    correlation_coefficients = np.array(correlation_coefficients)    uncertainty = np.std(correlation_coefficients)    mean = np.mean(correlation_coefficients)    return(correlation_coefficient1,uncertainty,mean)def calc_pearson(array1, array2):    array1 = np.array(array1)    array2 = np.array(array2)    correlation_coefficient1, _ = pearsonr(array1, array2)    # Bootstrapping to find uncertainty    num_bootstrap_samples = 1000    correlation_coefficients = []    for _ in range(num_bootstrap_samples):        # Resample array1 with replacement        resampled_array1_indices = np.random.choice(len(array1), size=len(array1), replace=True)        resampled_array1 = array1[resampled_array1_indices]        # Calculate correlation coefficient for the resampled arrays        correlation_coefficient, _ = pearsonr(resampled_array1, array2)        correlation_coefficients.append(correlation_coefficient)    correlation_coefficients = np.array(correlation_coefficients)    uncertainty = np.std(correlation_coefficients)    mean_bootstrap = np.mean(correlation_coefficients)    return correlation_coefficient1, uncertainty, mean_bootstrapdef calc_pearsonnomean(array1,array2):    array1 = np.array(array1)    array2 = np.array(array2)    correlation_coefficient1, _ = pearsonr(array1, array2)    #bootstrapping to find uncertainty    num_bootstrap_samples = 1000    correlation_coefficients = []    for _ in range(num_bootstrap_samples):        # Resample array1 with replacement        resampled_array1_indices = np.random.choice(len(array1), size=len(array1), replace=True)        resampled_array1 = array1[resampled_array1_indices]        # Calculate correlation coefficient for the resampled arrays        correlation_coefficient, _ = pearsonr(resampled_array1, array2)        correlation_coefficients.append(correlation_coefficient)    correlation_coefficients = np.array(correlation_coefficients)    uncertainty = np.std(correlation_coefficients)    return(correlation_coefficient1,uncertainty)def resample(x1, y1, x2):    """    Resample the dataset represented by (x1, y1) to match the x-values in x2    using cubic spline interpolation.    Parameters:        x1 (array-like): x-values of the original dataset.        y1 (array-like): y-values of the original dataset.        x2 (array-like): x-values of the target dataset.    Returns:        array-like: Resampled y-values corresponding to x2.    """    x1 = np.squeeze(x1)    # Create cubic spline interpolation using the original dataset    cs = CubicSpline(x1, y1)    # Evaluate the spline function at the x-values of the target dataset    y2_resampled = cs(x2)    return y2_resamplednudot_resampled = resample_using_cubic_spline(spindown_MJD_new, spindown_rate_new , MJD_new)srcc1_new,pvalue1, uncertainty1_new = calc_srcc(nudot_resampled, shape_parameter_new)srcc2_new,pvalue2, uncertainty2_new = calc_srcc(nudot_resampled, shape_parameter_new1)srcc3_new,pvalue3, uncertainty3_new = calc_srcc(nudot_resampled, shape_parameter_new2)srcc4_new,pvalue4, uncertainty4_new = calc_srcc(nudot_resampled, shape_parameter_new3)SP1_res_afb = resample(spindown_MJD_afb, MJD_afb, shape_parameter_afb)SP2_res_afb = resample(spindown_MJD_afb, MJD_afb, shape_parameter_afb1)SP3_res_afb = resample(spindown_MJD_afb, MJD_afb, shape_parameter_afb2)SP4_res_afb = resample(spindown_MJD_afb, MJD_afb, shape_parameter_afb3)pearson1,uncertainty1,mp1 = calc_pearson(spindown_rate_afb,SP1_res_afb)pearson2,uncertainty2,mp2 = calc_pearson(spindown_rate_afb,SP2_res_afb)pearson3,uncertainty3,mp3 = calc_pearson(spindown_rate_afb,SP3_res_afb)pearson4,uncertainty4,mp4 = calc_pearson(spindown_rate_afb,SP4_res_afb)SP_1_2_CORR,unc12, pm1 = calc_pearson(shape_parameter_afb,shape_parameter_afb1)SP_2_3_CORR, unc23, pm2 = calc_pearson(shape_parameter_afb1,shape_parameter_afb2)srcc1,suncertainty1, ms1 = calc_srcc(spindown_rate_afb,SP1_res_afb)srcc2,suncertainty2, ms2 = calc_srcc(spindown_rate_afb,SP2_res_afb)srcc3,suncertainty3, ms3 = calc_srcc(spindown_rate_afb,SP3_res_afb)srcc4,suncertainty4, ms4 = calc_srcc(spindown_rate_afb,SP4_res_afb)sSP_1_2_CORR,sunc12, sm1 = calc_srcc(shape_parameter_afb,shape_parameter_afb1)sSP_2_3_CORR, sunc23, sm2 = calc_srcc(shape_parameter_afb1,shape_parameter_afb2)print(f'pearson SP1 {pearson1}±{uncertainty1}   (mean = {mp1})')print(f'pearson SP2 {pearson2}±{uncertainty2}   (mean = {mp2})')print(f'pearson SP3 {pearson3}±{uncertainty3}   (mean = {mp3})')print(f'pearson SP4 {pearson4}±{uncertainty4}   (mean = {mp4})')print(f'{SP_1_2_CORR}±{unc12}   (mean = {pm1})')print(f'{SP_2_3_CORR}±{unc23}   (mean = {pm2})')print(f'Spearman SP1 {srcc1}±{suncertainty1}   (mean = {ms1})')print(f'Spearman SP2 {srcc2}±{suncertainty2}   (mean = {ms2})')print(f'Spearman SP3 {srcc3}±{suncertainty3}   (mean = {ms3})')print(f'Spearman SP4 {srcc4}±{suncertainty4}   (mean = {ms4})')print(f'{sSP_1_2_CORR}±{sunc12}   (mean = {sm1})')print(f'{sSP_2_3_CORR}±{sunc23}   (mean = {sm2})')fig, axes = plt.subplots(3, 1, figsize=(10, 6), gridspec_kw={'height_ratios': [0.5,0.5,0.5]})# Plot the spindown dfb on the second subplotaxes[0].plot(MJD_afb, shape_parameter_afb, color='red')axes[0].set_ylabel(f'shape parameter')axes[0].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[0].xaxis.set_visible(False)axes[1].plot(spindown_MJD_afb, SP1_res_afb, color='red')axes[1].set_ylabel(f'resampled shape parameter')axes[1].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[1].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[2].plot(spindown_MJD_afb, spindown_rate_afb, color='red')axes[2].set_ylabel(f'spindown rate')axes[2].set_xlim(evenly_spaced_mjd_afb[0], evenly_spaced_mjd_afb[-1])axes[2].xaxis.set_visible(False)fig.suptitle(f'demonstration of resampling for correlation coeff.', fontsize=16)plt.subplots_adjust(hspace=0)plt.tight_layout()  # Adjust layout to prevent overlapplt.show()#for dfbSP1_res_dfb = resample(spindown_MJD_dfb, MJD_dfb, shape_parameter_dfb)SP2_res_dfb = resample(spindown_MJD_dfb, MJD_dfb, shape_parameter_dfb1)SP3_res_dfb = resample(spindown_MJD_dfb, MJD_dfb, shape_parameter_dfb2)SP4_res_dfb = resample(spindown_MJD_dfb, MJD_dfb, shape_parameter_dfb3)pearson1_dfb,uncertainty1_dfb, dmp1 = calc_pearson(spindown_rate_dfb,SP1_res_dfb)pearson2_dfb,uncertainty2_dfb, dmp2 = calc_pearson(spindown_rate_dfb,SP2_res_dfb)pearson3_dfb,uncertainty3_dfb, dmp3 = calc_pearson(spindown_rate_dfb,SP3_res_dfb)pearson4_dfb,uncertainty4_dfb, dmp4 = calc_pearson(spindown_rate_dfb,SP4_res_dfb)SP_1_2_CORR_dfb,unc12_dfb, dmm = calc_pearson(shape_parameter_dfb,shape_parameter_dfb1)SP_2_3_CORR_dfb, unc23_dfb, dmm1 = calc_pearson(shape_parameter_dfb1,shape_parameter_dfb2)srcc1_dfb,srccU1_dfb, sms1 = calc_srcc(spindown_rate_dfb,SP1_res_dfb)srcc2_dfb,srccU2_dfb,sms2 = calc_srcc(spindown_rate_dfb,SP2_res_dfb)srcc3_dfb,srccU3_dfb, sms3 = calc_srcc(spindown_rate_dfb,SP3_res_dfb)srcc4_dfb,srccU4_dfb , sms4= calc_srcc(spindown_rate_dfb,SP4_res_dfb)sSP_1_2_CORR_dfb,sunc12_dfb, ss1 = calc_srcc(shape_parameter_dfb,shape_parameter_dfb1)sSP_2_3_CORR_dfb, sunc23_dfb,ss2 = calc_srcc(shape_parameter_dfb1,shape_parameter_dfb2)print(f'pearson {pearson1_dfb}±{uncertainty1_dfb}   (mean = {dmp1})')print(f'pearson {pearson2_dfb}±{uncertainty2_dfb}  (mean = {dmp2})')print(f'pearson {pearson3_dfb}±{uncertainty3_dfb}  (mean = {dmp3})')print(f'pearson {pearson4_dfb}±{uncertainty4_dfb}  (mean = {dmp4})')print(f'{SP_1_2_CORR_dfb}±{unc12_dfb}')print(f'{SP_2_3_CORR_dfb}±{unc23_dfb}')print(f'Spearman {srcc1_dfb}±{srccU1_dfb}  (mean = {sms1})')print(f'Spearman {srcc2_dfb}±{srccU2_dfb}  (mean = {sms2})')print(f'Spearman {srcc3_dfb}±{srccU3_dfb}  (mean = {sms3})')print(f'Spearman {srcc4_dfb}±{srccU4_dfb}  (mean = {sms4})')print(f'{sSP_1_2_CORR_dfb}±{sunc12_dfb}')print(f'{sSP_2_3_CORR_dfb}±{sunc23_dfb}')fig, axes = plt.subplots(3, 1, figsize=(10, 6), gridspec_kw={'height_ratios': [0.5,0.5,0.5]})# Plot the spindown dfb on the second subplotaxes[0].plot(MJD_dfb, shape_parameter_dfb, color='red')axes[0].set_ylabel(f'shape parameter')axes[0].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[0].xaxis.set_visible(False)axes[1].plot(spindown_MJD_dfb, SP1_res_dfb, color='red')axes[1].set_ylabel(f'resampled shape parameter')axes[1].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[1].xaxis.set_visible(False)# Plot the spindown dfb on the second subplotaxes[2].plot(spindown_MJD_dfb, spindown_rate_dfb, color='red')axes[2].set_ylabel(f'spindown rate')axes[2].set_xlim(evenly_spaced_mjd_dfb[0], evenly_spaced_mjd_dfb[-1])axes[2].xaxis.set_visible(False)